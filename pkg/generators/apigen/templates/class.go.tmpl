{{template "preamble"}}

import (
  "unsafe"
  "runtime"

  "github.com/LouisBrunner/go-dot-extension/pkg/gdc"
)

// FIXME: avoid unused import warning
var _ unsafe.Pointer
var _ runtime.Pinner

{{$Class := mapClass .Name -}}
type {{$Class}} struct {
  {{if .Inherits -}}
    {{mapClass .Inherits}}
  {{- else -}}
    obj gdc.ObjectPtr
{{- end}}
}
{{if not .Inherits}}
func (me *{{$Class}}) SetBaseObject(obj gdc.ObjectPtr) {
  me.obj = obj
}
{{end}}
func (me *{{$Class}}) BaseClass() string {
  return "{{.Name}}"
}

func New{{$Class}}() *{{$Class}} {
  str := StringNameFromStr("{{.Name}}") // FIXME: should cache?
  defer str.Destroy()

	objPtr := giface.ClassdbConstructObject(str.AsCPtr())
  obj := &{{$Class}}{}
  obj.SetBaseObject(objPtr)
  return obj
}

{{template "class_enums" .}}

func (me *{{$Class}}) Type() gdc.VariantType {
  return gdc.VariantTypeObject
}

func (me *{{$Class}}) AsTypePtr() gdc.TypePtr {
  return gdc.TypePtr(me.obj)
}

func (me *{{$Class}}) AsCTypePtr() gdc.ConstTypePtr {
  return gdc.ConstTypePtr(me.obj)
}

// Methods
{{- range .Methods}}
{{- if ne .Hash 0}}

func {{if .IsStatic }} {{$Class}}{{else}} (me *{{$Class}}) {{end }}{{mapMethod .Name -}}
({{range .Arguments}}{{mapName .Name}} {{mapWideType .Type}}, {{end}}
{{- if .IsVarArg}}varargs ...Variant{{end -}}
) {{if .ReturnValue}}{{mapWideType .ReturnValue.Type}}{{end}} {
  classNameV := StringNameFromStr("{{$.Name}}")
  defer classNameV.Destroy()
  methodNameV := StringNameFromStr("{{.Name}}")
  defer methodNameV.Destroy()
  methodPtr := giface.ClassdbGetMethodBind(classNameV.AsCPtr(), methodNameV.AsCPtr(), {{.Hash}}) // FIXME: should cache?
{{- if .IsVarArg}}
  cargs := make([]gdc.ConstVariantPtr, 0, {{len .Arguments}} + len(varargs)){{range $i, $e := .Arguments}}
{{if eq (mapWideType .Type) "Variant"}}
  cargs = append(cargs, {{mapName .Name}}.AsCPtr())
{{- else if eq (mapWideType .Type) "int64"}}  intVar{{$i}} := NewIntFromInt({{mapName .Name}})
  defer intVar{{$i}}.Destroy()
  var{{$i}} := intVar{{$i}}.AsVariant()
  defer var{{$i}}.Destroy()
  cargs = append(cargs, var{{$i}}.AsCPtr())
{{- else}}  var{{$i}} := {{mapName .Name}}.AsVariant()
  defer var{{$i}}.Destroy()
  cargs = append(cargs, var{{$i}}.AsCPtr())
{{- end -}}
{{- end}}
  for _, v := range varargs {
    cargs = append(cargs, v.AsCPtr())
  }
{{if .ReturnValue}}  ret := NewVariant()
{{end}}
  cerr := &gdc.CallError{}
  giface.ObjectMethodBindCall(methodPtr, {{if .IsStatic}}nil{{else}}me.obj{{end}}, unsafe.SliceData(cargs), gdc.Int(len(cargs)), {{if .ReturnValue}}ret.asUninitialized(){{else}}nil{{end}}, cerr)
  if cerr.Error != gdc.CallOk {
    panic(cerr) // TODO: return `cerr`?
  }
{{if .ReturnValue}}  {{if or (startsWith .ReturnValue.Type "enum::") (startsWith .ReturnValue.Type "bitfield::") -}}
defer ret.Destroy()
  retInt, err := ret.AsInt()
  if err != nil {
    panic(err) // TODO: return `err`?
  }
  return {{mapType .ReturnValue.Type}}(retInt.Get())
{{- else -}}
return *ret
{{- end}}{{end}}
{{else}}
  cargs := []gdc.ConstTypePtr{
    {{- range .Arguments}}
{{- if or (not (isExported (mapType .Type))) (or (startsWith .Type "enum::") (startsWith .Type "bitfield::")) -}}
    gdc.ConstTypePtr(&{{mapName .Name}}) {{/* TODO: not sure about this */}}
{{- else -}}
    {{mapName .Name}}.AsCTypePtr()
{{- end -}}
    , {{ end -}}
  }
  pinner := runtime.Pinner{}
  defer pinner.Unpin()
{{if .ReturnValue}}  {{if or (startsWith .ReturnValue.Type "enum::") (startsWith .ReturnValue.Type "bitfield::") -}}
var ret {{mapType .ReturnValue.Type}}
{{- else if startsWith .ReturnValue.Type "typedarray::" -}}
ret := NewArray()
  defer ret.Destroy()
{{- else -}}
ret := New{{mapClass .ReturnValue.Type}}()
{{- end}}
{{- range .Arguments}}
{{- if or (not (isExported (mapType .Type))) (or (startsWith .Type "enum::") (startsWith .Type "bitfield::"))}}
  pinner.Pin(&{{mapName .Name}})
{{- end -}}
{{- end}}
{{end}}
  giface.ObjectMethodBindPtrcall(methodPtr, {{if .IsStatic}}nil{{else}}me.obj{{end}}, unsafe.SliceData(cargs), {{if .ReturnValue -}}
{{- if or (startsWith .ReturnValue.Type "enum::") (startsWith .ReturnValue.Type "bitfield::") -}}
gdc.TypePtr(unsafe.Pointer(&ret))
{{- else -}}
ret.AsTypePtr()
{{- end -}}
{{- else}}nil{{end}})
{{if .ReturnValue}}  return {{if or (startsWith .ReturnValue.Type "enum::") (startsWith .ReturnValue.Type "bitfield::") -}}
ret
{{- else if startsWith .ReturnValue.Type "typedarray::" -}}
ConvertArrayToSlice[{{trimPrefix (mapWideType .ReturnValue.Type) "[]"}}](ret)
{{- else if isExported (mapType .ReturnValue.Type) -}}
*ret
{{- else -}}
ret.Get()
{{- end}}
{{- end}}
{{end -}}
}
{{- end}}{{end}}

{{- if .Properties}}
// Properties
// FIXME: can't seem to be able to use those from this side of the API
{{- end}}

// Signals
{{- range .Signals}}

type {{$Class}}{{pascalCased .Name}}SignalFn func({{range .Arguments}}{{mapName .Name}} {{mapType .Type}}, {{end}})

func (me *{{$Class}}) Connect{{pascalCased .Name}}(subs SignalSubscribers, fn {{$Class}}{{pascalCased .Name}}SignalFn) {
  sig := StringNameFromStr("{{.Name}}")
  defer sig.Destroy()
  me.Connect(*sig, subs.add(fn), 0)
}

func (me *{{$Class}}) Disconnect{{pascalCased .Name}}(subs SignalSubscribers, fn {{$Class}}{{pascalCased .Name}}SignalFn) {
  sig := StringNameFromStr("{{.Name}}")
  defer sig.Destroy()
  me.Disconnect(*sig, *subs.remove(fn))
}
{{- end}}
