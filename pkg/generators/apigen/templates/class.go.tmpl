{{template "preamble"}}

import (
  "unsafe"

  "github.com/LouisBrunner/go-dot-extension/pkg/gdc"
)

var _ unsafe.Pointer // FIXME: avoid unused import warning

{{$Class := mapClass .Name -}}
type {{$Class}} struct {
  {{if .Inherits -}}
    {{mapClass .Inherits}}
  {{- else -}}
    obj gdc.ObjectPtr
{{- end}}
}
{{if not .Inherits}}
func (me *{{$Class}}) SetBaseObject(obj gdc.ObjectPtr) {
  me.obj = obj
}
{{end}}
func (me *{{$Class}}) BaseClass() string {
  return "{{.Name}}"
}

{{template "class_enums" .}}

func (me *{{$Class}}) Type() gdc.VariantType {
  return gdc.VariantTypeObject
}

func (me *{{$Class}}) AsTypePtr() gdc.TypePtr {
  return gdc.TypePtr(me.obj)
}

func (me *{{$Class}}) AsCTypePtr() gdc.ConstTypePtr {
  return gdc.ConstTypePtr(me.obj)
}

// Methods
{{- range .Methods}}
{{- if ne .Hash 0}}

func {{if .IsStatic }} {{$Class}}{{else}} (me *{{$Class}}) {{end }}{{mapMethod .Name -}}
({{range .Arguments}}{{mapName .Name}} {{mapType .Type}}, {{end}}
{{- if .IsVarArg}}varargs ...Variant{{end -}}
) {{if .ReturnValue}}{{mapType .ReturnValue.Type}}{{end}} {
  classNameV := StringNameFromStr("{{$.Name}}")
  defer classNameV.Destroy()
  methodNameV := StringNameFromStr("{{.Name}}")
  defer methodNameV.Destroy()
  methodPtr := giface.ClassdbGetMethodBind(classNameV.AsCPtr(), methodNameV.AsCPtr(), {{.Hash}}) // FIXME: should cache?
{{- $vartype := ternary .IsVarArg "ConstVariantPtr" "ConstTypePtr"}}
{{if .ReturnValue}}  var ret {{mapType .ReturnValue.Type}}
{{end}}  cargs := []gdc.{{$vartype}}{
    {{- range .Arguments}}
{{- if isExported (mapType .Type) -}}
  {{- if startsWith .Type "enum::" -}}
    gdc.{{$vartype}}(&{{mapName .Name}})
  {{- else if startsWith .Type "bitfield::" -}}
    gdc.{{$vartype}}(&{{mapName .Name}})
  {{- else -}}
    gdc.{{$vartype}}({{mapName .Name}}.AsCTypePtr())
  {{- end -}}
{{- else -}}
  gdc.{{$vartype}}(&{{mapName .Name}})
{{- end -}}
    , {{ end -}}
  }
{{- if .IsVarArg}}
  for _, v := range varargs {
    cargs = append(cargs, v.AsCPtr())
  }
  err := &gdc.CallError{}
  giface.ObjectMethodBindCall(methodPtr, {{if .IsStatic}}nil{{else}}me.obj{{end}}, unsafe.SliceData(cargs), gdc.Int(len(cargs)), {{if .ReturnValue}}gdc.UninitializedVariantPtr(&ret){{else}}nil{{end}}, err)
  if err.Error != gdc.CallOk {
    panic(err) // TODO: return `err`?
  }
{{else}}
  giface.ObjectMethodBindPtrcall(methodPtr, {{if .IsStatic}}nil{{else}}me.obj{{end}}, unsafe.SliceData(cargs), {{if .ReturnValue}}gdc.TypePtr(&ret){{else}}nil{{end}})
{{- end}}
{{if .ReturnValue}}  return ret
{{end -}}
}
{{- end}}{{end}}

{{- if .Properties}}
// Properties
// FIXME: can't seem to be able to use those from this side of the API
{{- end}}

// Signals
{{- range .Signals}}

type {{$Class}}{{pascalCased .Name}}SignalFn func({{range .Arguments}}{{mapName .Name}} {{mapType .Type}}, {{end}})

func (me *{{$Class}}) Connect{{pascalCased .Name}}(subs SignalSubscribers, fn {{$Class}}{{pascalCased .Name}}SignalFn) {
  sig := StringNameFromStr("{{.Name}}")
  defer sig.Destroy()
  me.Connect(*sig, subs.add(fn), 0)
}

func (me *{{$Class}}) Disconnect{{pascalCased .Name}}(subs SignalSubscribers, fn {{$Class}}{{pascalCased .Name}}SignalFn) {
  sig := StringNameFromStr("{{.Name}}")
  defer sig.Destroy()
  me.Disconnect(*sig, *subs.remove(fn))
}
{{- end}}
